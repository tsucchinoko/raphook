use std::fs;
use std::io::{self};
use std::os::unix::fs::PermissionsExt;
use std::path::Path;

pub const AVAILABLE_HOOKS: &[&str] = &[
    "pre-commit",
    "prepare-commit-msg",
    "commit-msg",
    "post-commit",
    "pre-push",
];

fn ensure_hooks_dir_exists(path: &str) -> io::Result<String> {
    let hooks_dir = Path::new(path).join(".git").join("hooks");
    if !hooks_dir.exists() {
        fs::create_dir_all(&hooks_dir)?;
    }
    Ok(hooks_dir.to_string_lossy().into_owned())
}

fn install_hook(hooks_dir: &str, hook_name: &str) -> io::Result<()> {
    let hook_path = Path::new(hooks_dir).join(hook_name);
    let template = format!(
        r#"#!/bin/sh
# Generated by raphook
echo "[raphook] Running {} hook"
"#,
        hook_name
    );

    fs::write(&hook_path, template)?;
    fs::set_permissions(&hook_path, fs::Permissions::from_mode(0o755))?;
    Ok(())
}

pub fn install(path: &str) -> io::Result<Vec<String>> {
    let hooks_dir = ensure_hooks_dir_exists(path)?;
    let mut installed_hooks = Vec::new();

    for &hook in AVAILABLE_HOOKS {
        match install_hook(&hooks_dir, hook) {
            Ok(_) => installed_hooks.push(hook.to_string()),
            Err(e) => eprintln!("Failed to install {}: {}", hook, e),
        }
    }

    Ok(installed_hooks)
}
